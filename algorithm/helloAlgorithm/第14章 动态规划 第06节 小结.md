# 小结

- 动态规划对问题进行分解，并通过【存储子问题的解】来规避重复计算，提高计算效率。
- 不考虑时间的前提下，所有【动态规划】问题都可以用【回溯（暴力搜索）】进行求解，
  但【递归树】中存在【大量的重叠子问题】，效率极低。
  通过引入【记忆化列表】，可以存储所有计算过的子问题的解，从而保证重叠子问题只被计算一次。
- 记忆化搜索是一种从顶至底的递归式解法，而与之对应的动态规划是一种从底至顶的递推式解法，其如同“填写表格”一样。
  由于当前状态仅依赖某些局部状态，因此我们可以消除dp表的一个维度，从而降低空间复杂度。
- 子问题分解是一种通用的算法思路，在分治、动态规划、回溯中具有不同的性质。
- 动态规划问题有三大特性：【重叠子问题】、【最优子结构】、【无后效性】。
- 如果原问题的最优解可以从子问题的最优解构建得来，则它就具有最优子结构。
- 无后效性指对于一个状态，其未来发展只与该状态有关，而与过去经历的所有状态无关。
  许多组合优化问题不具有无后效性，无法使用动态规划快速求解。

**背包问题**

- 背包问题是最典型的动态规划问题之一，具有0-1背包、完全背包、多重背包等变种。
- 0-1背包的状态定义为前i个物品在剩余容量为c的背包中的最大价值。
  根据不放入背包和放入背包两种决策，可得到最优子结构，并构建出状态转移方程。
  在空间优化中，由于每个状态依赖正上方和左上方的状态，因此需要倒序遍历列表，避免左上方状态被覆盖。
- 完全背包问题的每种物品的选取数量无限制，因此选择放入物品的状态转移与0-1背包问题不同。
  由于状态依赖正上方和正左方的状态，因此在空间优化中应当正序遍历。
- 零钱兑换问题是完全背包问题的一个变种。
  它从求“最大”价值变为求“最小”硬币数量，因此状态转移方程中的max()应改为min()。
  从追求“不超过”背包容量到追求“恰好”凑出目标金额，因此使用amt + 1来表示“无法凑出目标金额”的无效解。
- 零钱兑换问题II从求“最少硬币数量”改为求“硬币组合数量”，状态转移方程相应地从min()改为求和运算符。

